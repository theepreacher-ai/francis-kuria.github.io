<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building a Custom Vulnerability Scanner with Python ‚Äî Francis Kuria</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: rgba(26, 26, 46, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px 0;
            margin-bottom: 40px;
            border-bottom: 2px solid #3a86ff;
        }
        
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 900px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #3a86ff;
            text-decoration: none;
        }
        
        nav ul {
            display: flex;
            list-style: none;
            gap: 30px;
        }
        
        nav a {
            color: #e0e0e0;
            text-decoration: none;
            transition: color 0.3s;
        }
        
        nav a:hover {
            color: #3a86ff;
        }
        
        .article-header {
            margin-bottom: 40px;
        }
        
        .article-meta {
            color: #888;
            font-size: 14px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .tag {
            background: rgba(58, 134, 255, 0.2);
            padding: 5px 15px;
            border-radius: 20px;
            color: #3a86ff;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        h1 {
            font-size: 42px;
            color: #ffffff;
            margin-bottom: 20px;
            line-height: 1.2;
        }
        
        h2 {
            font-size: 32px;
            color: #ffffff;
            margin: 40px 0 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3a86ff;
        }
        
        h3 {
            font-size: 24px;
            color: #3a86ff;
            margin: 30px 0 15px;
        }
        
        p {
            margin-bottom: 20px;
            font-size: 17px;
            color: #d0d0d0;
        }
        
        code {
            background: rgba(58, 134, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #3a86ff;
            font-size: 15px;
        }
        
        pre {
            background: #0d1117;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #3a86ff;
        }
        
        pre code {
            background: none;
            padding: 0;
            color: #e0e0e0;
            font-size: 14px;
            display: block;
            line-height: 1.5;
        }
        
        ul, ol {
            margin: 20px 0 20px 40px;
            color: #d0d0d0;
        }
        
        li {
            margin-bottom: 10px;
            font-size: 17px;
        }
        
        .highlight {
            background: rgba(58, 134, 255, 0.1);
            border-left: 4px solid #3a86ff;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .back-link {
            display: inline-block;
            color: #3a86ff;
            text-decoration: none;
            margin-top: 40px;
            padding: 10px 20px;
            border: 2px solid #3a86ff;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        .back-link:hover {
            background: #3a86ff;
            color: #ffffff;
        }
        
        footer {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            margin-top: 60px;
            border-top: 1px solid rgba(58, 134, 255, 0.2);
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <a href="../index.html" class="logo">üõ°Ô∏è Francis Kuria</a>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../index.html#work">Projects</a></li>
                <li><a href="index.html">Blog</a></li>
                <li><a href="../index.html#contact">Contact</a></li>
            </ul>
        </nav>
    </header>

    <div class="container">
        <article>
            <div class="article-header">
                <div class="article-meta">
                    <span class="tag">üõ†Ô∏è Tools</span>
                    <span class="tag">Automation</span>
                    <span>üìÖ Jan 5, 2026</span>
                    <span>‚è±Ô∏è 10 min read</span>
                </div>
                <h1>Building a Custom Vulnerability Scanner with Python</h1>
            </div>

            <p>Automated vulnerability scanners are essential tools in any security professional's arsenal. While commercial solutions like Nessus and OpenVAS are powerful, building your own scanner provides deep insights into how vulnerabilities are detected and gives you complete control over the scanning process. In this guide, we'll build a practical vulnerability scanner from scratch using Python.</p>

            <h2>Why Build Your Own Scanner?</h2>

            <p>Before diving into code, let's understand the benefits of creating a custom vulnerability scanner:</p>

            <ul>
                <li><strong>Learning</strong>: You'll gain deep understanding of network protocols, service enumeration, and vulnerability detection techniques</li>
                <li><strong>Customization</strong>: Tailor the scanner to your specific needs, environments, or compliance requirements</li>
                <li><strong>Integration</strong>: Easily integrate with your existing security workflows and tools</li>
                <li><strong>Performance</strong>: Optimize for your specific use cases without bloat from unnecessary features</li>
            </ul>

            <h2>Core Components of a Vulnerability Scanner</h2>

            <p>A comprehensive vulnerability scanner typically consists of these key components:</p>

            <h3>1. Network Discovery</h3>
            <p>Identifying active hosts on the network using techniques like ICMP ping sweeps, ARP scanning, or TCP SYN scans.</p>

            <h3>2. Port Scanning</h3>
            <p>Determining which ports are open on target hosts to identify running services.</p>

            <h3>3. Service Enumeration</h3>
            <p>Fingerprinting services to determine their type, version, and configuration.</p>

            <h3>4. Vulnerability Detection</h3>
            <p>Checking for known vulnerabilities based on service versions, configurations, or active testing.</p>

            <h3>5. Reporting</h3>
            <p>Generating actionable reports with findings, severity ratings, and remediation guidance.</p>

            <h2>Building the Scanner</h2>

            <p>Let's build our scanner step by step. We'll use Python 3 with libraries like <code>scapy</code>, <code>nmap</code>, and <code>requests</code>.</p>

            <h3>Setting Up the Environment</h3>

            <pre><code># Install required dependencies
pip install scapy python-nmap requests colorama

# For Scapy on Linux, you may need root privileges
# or use capabilities: sudo setcap cap_net_raw+ep /usr/bin/python3</code></pre>

            <h3>Core Scanner Class</h3>

            <pre><code>import nmap
import socket
import requests
from datetime import datetime
import json

class VulnerabilityScanner:
    def __init__(self, target):
        self.target = target
        self.nm = nmap.PortScanner()
        self.results = {
            'target': target,
            'scan_time': datetime.now().isoformat(),
            'hosts': [],
            'vulnerabilities': []
        }
    
    def scan_ports(self, ports='1-1000'):
        """Perform port scanning on the target"""
        print(f"[*] Scanning ports {ports} on {self.target}...")
        
        try:
            self.nm.scan(self.target, ports, arguments='-sV -sC -O')
            
            for host in self.nm.all_hosts():
                host_info = {
                    'ip': host,
                    'hostname': self.nm[host].hostname(),
                    'state': self.nm[host].state(),
                    'ports': []
                }
                
                for proto in self.nm[host].all_protocols():
                    ports = self.nm[host][proto].keys()
                    
                    for port in ports:
                        port_info = {
                            'port': port,
                            'state': self.nm[host][proto][port]['state'],
                            'service': self.nm[host][proto][port]['name'],
                            'version': self.nm[host][proto][port].get('version', 'unknown')
                        }
                        host_info['ports'].append(port_info)
                
                self.results['hosts'].append(host_info)
                
        except Exception as e:
            print(f"[!] Error during port scan: {str(e)}")
        
        return self.results
    
    def check_service_vulnerabilities(self):
        """Check for known vulnerabilities in detected services"""
        print("[*] Checking for service vulnerabilities...")
        
        vuln_db = self.load_vulnerability_database()
        
        for host in self.results['hosts']:
            for port in host['ports']:
                service = port['service']
                version = port['version']
                
                # Check against vulnerability database
                vulns = self.match_vulnerabilities(service, version, vuln_db)
                
                for vuln in vulns:
                    self.results['vulnerabilities'].append({
                        'host': host['ip'],
                        'port': port['port'],
                        'service': service,
                        'version': version,
                        'vulnerability': vuln['name'],
                        'severity': vuln['severity'],
                        'cve': vuln.get('cve', 'N/A'),
                        'description': vuln['description']
                    })
    
    def load_vulnerability_database(self):
        """Load or create vulnerability signature database"""
        # In production, this would query CVE databases or custom signatures
        return [
            {
                'service': 'apache',
                'version_pattern': '2.4.[0-49]',
                'name': 'Apache HTTP Server Path Traversal',
                'severity': 'HIGH',
                'cve': 'CVE-2021-41773',
                'description': 'Path traversal and code execution vulnerability'
            },
            {
                'service': 'ssh',
                'version_pattern': 'OpenSSH_7.[0-7]',
                'name': 'OpenSSH Username Enumeration',
                'severity': 'MEDIUM',
                'cve': 'CVE-2018-15473',
                'description': 'Username enumeration via timing attack'
            },
            # Add more vulnerability signatures
        ]
    
    def match_vulnerabilities(self, service, version, vuln_db):
        """Match service versions against vulnerability database"""
        import re
        matches = []
        
        for vuln in vuln_db:
            if service.lower() in vuln['service'].lower():
                # Simple pattern matching (in production, use proper version comparison)
                if re.search(vuln['version_pattern'], version):
                    matches.append(vuln)
        
        return matches
    
    def generate_report(self, output_file='scan_report.json'):
        """Generate detailed scan report"""
        with open(output_file, 'w') as f:
            json.dump(self.results, f, indent=4)
        
        print(f"\n[+] Report saved to {output_file}")
        self.print_summary()
    
    def print_summary(self):
        """Print scan summary to console"""
        print("\n" + "="*60)
        print("VULNERABILITY SCAN SUMMARY")
        print("="*60)
        print(f"Target: {self.target}")
        print(f"Scan Time: {self.results['scan_time']}")
        print(f"Hosts Found: {len(self.results['hosts'])}")
        print(f"Vulnerabilities Found: {len(self.results['vulnerabilities'])}")
        
        if self.results['vulnerabilities']:
            print("\nVULNERABILITIES:")
            for vuln in self.results['vulnerabilities']:
                print(f"\n  [{vuln['severity']}] {vuln['vulnerability']}")
                print(f"  Host: {vuln['host']}:{vuln['port']}")
                print(f"  Service: {vuln['service']} {vuln['version']}")
                print(f"  CVE: {vuln['cve']}")
        
        print("="*60)</code></pre>

            <h3>Web Application Vulnerability Checks</h3>

            <p>Let's add web-specific vulnerability detection:</p>

            <pre><code>class WebVulnerabilityChecker:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Security Scanner)'
        })
    
    def check_sql_injection(self, param_url):
        """Basic SQL injection detection"""
        payloads = ["'", "1' OR '1'='1", "'; DROP TABLE users--"]
        
        for payload in payloads:
            try:
                response = self.session.get(f"{param_url}{payload}")
                
                # Check for SQL error messages
                sql_errors = [
                    "SQL syntax",
                    "mysql_fetch",
                    "ORA-01",
                    "PostgreSQL",
                    "SQLite",
                    "Unclosed quotation mark"
                ]
                
                for error in sql_errors:
                    if error.lower() in response.text.lower():
                        return {
                            'vulnerable': True,
                            'payload': payload,
                            'evidence': error
                        }
            except:
                pass
        
        return {'vulnerable': False}
    
    def check_xss(self, param_url):
        """Basic XSS detection"""
        payload = "<script>alert('XSS')</script>"
        
        try:
            response = self.session.get(f"{param_url}{payload}")
            
            if payload in response.text:
                return {
                    'vulnerable': True,
                    'type': 'Reflected XSS',
                    'payload': payload
                }
        except:
            pass
        
        return {'vulnerable': False}
    
    def check_security_headers(self):
        """Check for missing security headers"""
        try:
            response = self.session.get(self.base_url)
            headers = response.headers
            
            missing_headers = []
            recommended_headers = {
                'X-Frame-Options': 'DENY or SAMEORIGIN',
                'X-Content-Type-Options': 'nosniff',
                'Strict-Transport-Security': 'max-age=31536000',
                'Content-Security-Policy': 'Restrictive CSP',
                'X-XSS-Protection': '1; mode=block'
            }
            
            for header, value in recommended_headers.items():
                if header not in headers:
                    missing_headers.append({
                        'header': header,
                        'recommended': value
                    })
            
            return missing_headers
            
        except Exception as e:
            return []</code></pre>

            <h3>Using the Scanner</h3>

            <pre><code># Example usage
if __name__ == "__main__":
    # Network scan
    scanner = VulnerabilityScanner("192.168.1.0/24")
    scanner.scan_ports("1-1000")
    scanner.check_service_vulnerabilities()
    scanner.generate_report()
    
    # Web application scan
    web_scanner = WebVulnerabilityChecker("https://example.com")
    
    # Check for SQL injection
    sqli_result = web_scanner.check_sql_injection(
        "https://example.com/search?q="
    )
    
    # Check security headers
    headers = web_scanner.check_security_headers()
    print(f"Missing security headers: {len(headers)}")</code></pre>

            <h2>Advanced Features to Add</h2>

            <div class="highlight">
                <h3>Enhancements for Production Use:</h3>
                <ul>
                    <li><strong>Concurrent Scanning</strong>: Use threading or asyncio for faster scans</li>
                    <li><strong>CVE Database Integration</strong>: Connect to NVD API or local CVE database</li>
                    <li><strong>Custom Plugins</strong>: Plugin architecture for extensibility</li>
                    <li><strong>Rate Limiting</strong>: Respect target systems and avoid detection</li>
                    <li><strong>Authentication</strong>: Support authenticated scans</li>
                    <li><strong>Reporting Formats</strong>: Export to HTML, PDF, CSV</li>
                    <li><strong>False Positive Reduction</strong>: Implement verification checks</li>
                </ul>
            </div>

            <h2>Legal and Ethical Considerations</h2>

            <p><strong>Important:</strong> Only scan systems you own or have explicit written permission to test. Unauthorized vulnerability scanning is illegal in most jurisdictions. Always:</p>

            <ul>
                <li>Obtain written authorization before scanning</li>
                <li>Define scope and boundaries clearly</li>
                <li>Respect rate limits and system resources</li>
                <li>Document all activities and findings</li>
                <li>Handle discovered vulnerabilities responsibly</li>
            </ul>

            <h2>Conclusion</h2>

            <p>Building a custom vulnerability scanner teaches you fundamental security concepts while providing a powerful tool for your security testing toolkit. Start with the basic implementation above and gradually add features as your needs evolve. Remember that vulnerability scanning is just one component of a comprehensive security program.</p>

            <p>The complete source code for this scanner, including additional modules and documentation, is available on my GitHub. Feel free to extend it, contribute improvements, or use it as a foundation for your own security tools.</p>

            <a href="index.html" class="back-link">‚Üê Back to Blog</a>
        </article>
    </div>

    <footer>
        <p>¬© 2026 Francis Kuria ‚Ä¢ Sharing security knowledge, one post at a time</p>
    </footer>
</body>
</html>
